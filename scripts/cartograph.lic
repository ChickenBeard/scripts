=begin
  This is the lich script for managing your Cartograph DB:

  repo: https://github.com/elanthia-online/cartograph
  Required: Lich 4.3.12
  Author: Ondreian
  version: 0.0.1-rc
  Tags: mapdb, cartograph
  
=end

require "net/http"
require "rubygems/package"
require "benchmark"
require "zlib"
require "fileutils"
require "open-uri"
require "ostruct"

module Cartograph
  ##
  ## contextual logging
  ##
  module Log  
    def self.out(msg, label: :debug)
      return _write _view(msg, label) unless msg.is_a?(Exception)
      ## pretty-print exception
      _write _view(msg.message, label)
      msg.backtrace.to_a.slice(0..5).each do |frame| _write _view(frame, label) end
    end

    def self._write(line)
      if Script.current.vars.include?("--headless") or not defined?(:_respond)
        $stdout.write(line + "\n")
      elsif line.include?("<") and line.include?(">")
        respond(line)
      else
        _respond Preset.as(:debug, line)
      end
    end

    def self._view(msg, label)
      label = [Script.current.name, label].flatten.compact.join(".")
      safe = msg.inspect
      #safe = safe.gsub("<", "&lt;").gsub(">", "&gt;") if safe.include?("<") and safe.include?(">")
      "[#{label}] #{safe}"
    end

    def self.pp(msg, label = :debug)
      respond _view(msg, label)
    end

    def self.dump(*args)
      pp(*args)
    end

    module Preset
      def self.as(kind, body)
        %[<preset id="#{kind}">#{body}</preset>]
      end
    end
  end
  ##
  ## minimal options parser
  ##
  module Opts
    FLAG_PREFIX = "--"
    
    def self.parse_command(h, c)
      h[c.to_sym] = true
    end

    def self.parse_flag(h, f)
      (name, val) = f[2..-1].split("=")
      if val.nil?
        h[name.to_sym] = true
      else
        val = val.split(",")

        h[name.to_sym] = val.size == 1 ? val.first : val
      end
    end

    def self.parse(args = Script.current.vars[1..-1])   
      @opts ||= _parse(args)
      @opts   = _parse(args) unless @script.eql?(Script.current) 
      @script = Script.current
      return @opts
    end

    def self._parse(args)
      OpenStruct.new(**args.to_a.reduce(Hash.new) do |opts, v|
        if v.start_with?(FLAG_PREFIX)
          Opts.parse_flag(opts, v)
        else
          Opts.parse_command(opts, v)
        end
        opts
      end)
    end

    def self.method_missing(method, *args)
      parse.send(method, *args)
    end
  end
end

module Cartograph
  CARTO_DIR       = File.join($data_dir, "_cartograph")
  CURRENT_MAP_DIR = File.join(CARTO_DIR, "current")
  STAGING_MAP_DIR = File.join(CARTO_DIR, "_staging")
  
  REPO     = "https://github.com/elanthia-online/cartograph/tarball/master"
  CHECKSUM = "https://raw.githubusercontent.com/elanthia-online/cartograph/master/checksum"

  def self.setup_dirs()
    FileUtils.mkdir_p STAGING_MAP_DIR
  end

  def self.get_checksum()
    Net::HTTP.get URI.parse CHECKSUM
  end

  def self.staging_archive()
    staging_path(remote_checksum) + ".tar.gz"
  end

  def self.staging_path(*rest)
    File.join(STAGING_MAP_DIR, *rest)
  end

  def self.remote_checksum()
    @_remote_checksum ||= get_checksum()
  end

  def self.current_checksum()
    local_checksum_file = File.join(CURRENT_MAP_DIR, "checksum")
    return nil unless File.exists? local_checksum_file
    File.read local_checksum_file
  end

  def self.download_mapdb()
    setup_dirs
    download = File.new(staging_archive, "wb")
    Log.out("... downloading tarball from #{REPO}", label: :download)
    stream = open URI.parse REPO
    download.write(stream.read)
    # extra the tarball path
    return File.basename stream.meta["content-disposition"].split(" ").last, ".tar.gz"
  end

  def self.extract_tarball_mapdb()
    Log.out("... extracting mapdb from #{staging_archive}", label: :download)
    extraction_dir = staging_path(remote_checksum)
    FileUtils.mkdir_p(extraction_dir)
    Gem::Package.new("mapdb/#{remote_checksum}").extract_tar_gz(
      File.open(staging_archive), 
      extraction_dir)
  end

  def self.swap_staging_to_current()
    old_checksum = current_checksum
    new_mapdb = Dir[staging_path(remote_checksum, "/elanthia-online-cartograph-*")].first
    FileUtils.mv(CURRENT_MAP_DIR, File.join(CARTO_DIR, "rev-#{old_checksum}")) unless old_checksum.nil?
    #Log.out("swapping #{new_mapdb} to :current")
    FileUtils.mv(new_mapdb, CURRENT_MAP_DIR)
    Log.out("updated mapdb from #{old_checksum || ":none"} -> #{current_checksum}", label: :ok)
  end

  def self.cleanup_stage()
    staging_dir = staging_path(current_checksum)
    staging_tarball = staging_path(current_checksum + ".tar.gz")
    FileUtils.remove_dir(staging_dir) if File.directory?(staging_dir)
    FileUtils.rm(staging_tarball) if File.exists?(staging_tarball)
    :ok
  end

  def self.try_update(force: false)
    return :noop if current_checksum.eql?(remote_checksum)
    runtime = Benchmark.realtime { 
      download_mapdb() unless (File.exists?(staging_archive) and not force)
      extract_tarball_mapdb() unless (Dir.exists?(staging_path(remote_checksum)) and not force)
      swap_staging_to_current()
      cleanup_stage()
    }
    Log.out("updated mapdb in #{runtime.round}s", label: :perf)
    :ok
  end

  def self.main()
    return try_update(force: true) if Opts["force-update"]
    try_update()
  end

  main()
end